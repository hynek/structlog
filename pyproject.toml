# SPDX-License-Identifier: MIT OR Apache-2.0

[build-system]
requires = ["flit_core >=3.2,<4"]
build-backend = "flit_core.buildapi"

[project]
name = "structlog"
authors = [{name = "Hynek Schlawack", email = "hs@ox.cx"}]
dynamic = ["version", "description"]
requires-python = ">=3.6"
dependencies = [
    "typing-extensions; python_version<'3.8'"
]
license = { file = "LICENSE" }
keywords = ["logging", "structured", "structure", "log"]
classifiers = [
    "Development Status :: 5 - Production/Stable",
    "Intended Audience :: Developers",
    "License :: OSI Approved :: Apache Software License",
    "License :: OSI Approved :: MIT License",
    "Natural Language :: English",
    "Operating System :: OS Independent",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.6",
    "Programming Language :: Python :: 3.7",
    "Programming Language :: Python :: 3.8",
    "Programming Language :: Python :: 3.9",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: Implementation :: CPython",
    "Programming Language :: Python :: Implementation :: PyPy",
    "Programming Language :: Python",
    "Topic :: Software Development :: Libraries :: Python Modules",
    "Topic :: System :: Logging",
]

[project.urls]
Changelog = "https://www.structlog.org/en/stable/changelog.html"
Documentation = "https://www.structlog.org/"
"Bug Tracker" = "https://github.com/hynek/structlog/issues"
"Source Code" = "https://github.com/hynek/structlog"
Funding = "https://github.com/sponsors/hynek"
Tidelift = "https://tidelift.com/subscription/pkg/pypi-structlog?utm_source=pypi-structlog&utm_medium=pypi"
Ko-fi = "https://ko-fi.com/the_hynek"

[tool.flit.sdist]
include = [
    ".pre-commit-config.yaml",
    ".readthedocs.yml",
    "codecov.yml",
    "*.ini",
    "*.rst",
    "LICENSE.*",
    "docs",
    "tests",
    ".github",
    "show_off.py",
]
exclude = [
    "docs/_build",
    "tests/__pycache__",
    "tests/.mypy_cache",
]

[project.optional-dependencies]
tests = [
    "coverage[toml]",
    "freezegun>=0.2.8",
    "pretend",
    "pytest-asyncio",
    "pytest>=6.0",
    "simplejson",
]
docs = [
    "furo",
    "sphinx",
    "sphinxcontrib-mermaid",
    "twisted",
]

# We make `dev = [` part of the output so cog doesn't dedent the list.
# Refresh using `tox -e cog`
# [[[cog
# import cog, pathlib, tomli
# cfg = tomli.loads(pathlib.Path("pyproject.toml").read_text())
# opt = cfg["project"]["optional-dependencies"]
# dev = ["pre-commit", "rich", "cogapp", "tomli"]
# cog.outl("dev = [")
# for dep in dev + opt["tests"] + opt["docs"]:
#     cog.outl(f'    "{dep}",')
# ]]]
dev = [
    "pre-commit",
    "rich",
    "cogapp",
    "tomli",
    "coverage[toml]",
    "freezegun>=0.2.8",
    "pretend",
    "pytest-asyncio",
    "pytest>=6.0",
    "simplejson",
    "furo",
    "sphinx",
    "sphinxcontrib-mermaid",
    "twisted",
# [[[end]]]
]

[tool.pytest.ini_options]
addopts = "-ra --strict-markers "
xfail_strict = true
testpaths = "tests"
filterwarnings = [
    "once::Warning",
]


[tool.coverage.run]
parallel = true
branch = true
source = ["structlog"]

[tool.coverage.paths]
source = ["src", ".tox/*/site-packages"]

[tool.coverage.report]
show_missing = true
skip_covered = true
exclude_lines = [
    # a more strict default pragma
    "\\# pragma: no cover\\b",

    # allow defensive code
    "^\\s*raise AssertionError\\b",
    "^\\s*raise NotImplementedError\\b",
    "^\\s*return NotImplemented\\b",
    "^\\s*raise$",

    # typing-related code
    "^if (False|TYPE_CHECKING):",
    ": \\.\\.\\.(\\s*#.*)?$",
    "^ +\\.\\.\\.$",
    "-> ['\"]?NoReturn['\"]?:",
]


[tool.black]
line-length = 79


[tool.isort]
profile = "attrs"


[project.readme]
content-type = "text/x-rst"
# Load README.rst, but remove header and badges.
# Refresh using `tox -e cog`
# [[[cog
# import cog, pathlib
# cog.out('text = """')
# cog.out(pathlib.Path("README.rst").read_text().split(".. -begin-short-")[1].lstrip().replace('"""', r'\"\"\"') + '"""')
# ]]]
text = """``structlog`` makes logging in Python **faster**, **less painful**, and **more powerful** by adding **structure** to your log entries.
It has been successfully used in production at every scale since **2013**, while embracing cutting-edge technologies like *asyncio* or type hints along the way, and `influenced the design <https://twitter.com/sirupsen/status/638330548361019392>`_ of `structured logging packages in other ecosystems <https://github.com/sirupsen/logrus>`_.

Thanks to its highly flexible design, it's up to you whether you want ``structlog`` to take care about the **output** of your log entries or whether you prefer to **forward** them to an existing logging system like the standard library's ``logging`` module.

.. image:: https://github.com/hynek/structlog/blob/main/docs/_static/console_renderer.png?raw=true

.. -end-short-

Once you feel inspired to try it out, check out our friendly `Getting Started tutorial <https://www.structlog.org/en/stable/getting-started.html>`_ that also contains detailed installation instructions!

.. -begin-spiel-

If you prefer videos over reading, check out this DjangoCon Europe 2019 talk by `Markus Holtermann <https://twitter.com/m_holtermann>`_: "`Logging Rethought 2: The Actions of Frank Taylor Jr. <https://www.youtube.com/watch?v=Y5eyEgyHLLo>`_".


Easier Logging
==============

You can stop writing prose and start thinking in terms of an event that happens in the context of key/value pairs:

.. code-block:: pycon

   >>> from structlog import get_logger
   >>> log = get_logger()
   >>> log.info("key_value_logging", out_of_the_box=True, effort=0)
   2020-11-18 09:17.09 [info     ] key_value_logging              effort=0 out_of_the_box=True

Each log entry is a meaningful dictionary instead of an opaque string now!


Data Binding
============

Since log entries are dictionaries, you can start binding and re-binding key/value pairs to your loggers to ensure they are present in every following logging call:

.. code-block:: pycon

   >>> log = log.bind(user="anonymous", some_key=23)
   >>> log = log.bind(user="hynek", another_key=42)
   >>> log.info("user.logged_in", happy=True)
   2020-11-18 09:18.28 [info     ] user.logged_in                 another_key=42 happy=True some_key=23 user=hynek

You can also bind key/value pairs to `thread-local storage <https://www.structlog.org/en/stable/thread-local.html>`_ and `contextvars <https://www.structlog.org/en/stable/contextvars.html>`_.


Powerful Pipelines
==================

Each log entry goes through a `processor pipeline <https://www.structlog.org/en/stable/processors.html>`_ that is just a chain of functions that receive a dictionary and return a new dictionary that gets fed into the next function.
That allows for simple but powerful data manipulation:

.. code-block:: python

   def timestamper(logger, log_method, event_dict):
       \"\"\"Add a timestamp to each log entry.\"\"\"
       event_dict["timestamp"] = time.time()
       return event_dict

There are `plenty of processors <https://www.structlog.org/en/stable/api.html#module-structlog.processors>`_ for most common tasks coming with ``structlog``:

- Collectors of `call stack information <https://www.structlog.org/en/stable/api.html#structlog.processors.StackInfoRenderer>`_ ("How did this log entry happen?"),
- …and `exceptions <https://www.structlog.org/en/stable/api.html#structlog.processors.format_exc_info>`_ ("What happened‽").
- Unicode encoders/decoders.
- Flexible `timestamping <https://www.structlog.org/en/stable/api.html#structlog.processors.TimeStamper>`_.


Formatting
==========

``structlog`` is completely flexible about *how* the resulting log entry is emitted.
Since each log entry is a dictionary, it can be formatted to **any** format:

- A colorful key/value format for `local development <https://www.structlog.org/en/stable/development.html>`_,
- `JSON <https://www.structlog.org/en/stable/api.html#structlog.processors.JSONRenderer>`_ for easy parsing,
- or some standard format you have parsers for like nginx or Apache httpd.

Internally, formatters are processors whose return value (usually a string) is passed into loggers that are responsible for the output of your message.
``structlog`` comes with multiple useful formatters out-of-the-box.


Output
======

``structlog`` is also very flexible with the final output of your log entries:

- A **built-in** lightweight printer like in the examples above.
  Easy to use and fast.
- Use the **standard library**'s or **Twisted**'s logging modules for compatibility.
  In this case ``structlog`` works like a wrapper that formats a string and passes them off into existing systems that won't ever know that ``structlog`` even exists.
  Or the other way round: ``structlog`` comes with a ``logging`` formatter that allows for processing third party log records.
- Don't format it to a string at all!
  ``structlog`` passes you a dictionary and you can do with it whatever you want.
  Reported uses cases are sending them out via network or saving them in a database.


Highly Testable
===============

``structlog`` is thouroughly tested and we see it as our duty to help you to achieve the same in *your* applications.
That's why it ships with a `bunch of helpers <https://www.structlog.org/en/stable/testing.html>`_ to introspect your application's logging behavior with little-to-no boilerplate.

.. -end-spiel-

.. -begin-meta-

Getting Help
============

Please use the ``structlog`` tag on `StackOverflow <https://stackoverflow.com/questions/tagged/structlog>`_ to get help.

Answering questions of your fellow developers is also a great way to help the project!


Project Information
===================

``structlog`` is dual-licensed under `Apache License, version 2 <https://choosealicense.com/licenses/apache/>`_ and `MIT <https://choosealicense.com/licenses/mit/>`_, available from `PyPI <https://pypi.org/project/structlog/>`_, the source code can be found on `GitHub <https://github.com/hynek/structlog>`_, the documentation at https://www.structlog.org/.

We collect useful third-party extension in `our wiki <https://github.com/hynek/structlog/wiki/Third-party-Extensions>`_.

``structlog`` targets Python 3.6 and later; including PyPy3.


``structlog`` for Enterprise
----------------------------

Available as part of the Tidelift Subscription.

The maintainers of structlog and thousands of other packages are working with Tidelift to deliver commercial support and maintenance for the open source packages you use to build your applications. Save time, reduce risk, and improve code health, while paying the maintainers of the exact packages you use.
`Learn more. <https://tidelift.com/subscription/pkg/pypi-structlog?utm_source=pypi-structlog&utm_medium=referral&utm_campaign=readme>`_
"""
# [[[end]]]
